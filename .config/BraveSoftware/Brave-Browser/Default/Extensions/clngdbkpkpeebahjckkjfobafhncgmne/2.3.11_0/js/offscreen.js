"use strict";{const e=self,t=e,r=e.document;(()=>{const apiHandler={get:({name:path},name)=>new Proxy(Object.defineProperty(()=>{},"name",{value:path?path+"."+name:name}),apiHandler),apply:async function({name:path},thisObj,args){const localErr=new Error,msg={data:{method:"invokeAPI",path,args},TDM};for(let res,err,retry=0;retry<2;retry++){try{if(res=await chrome.runtime.sendMessage(msg),res){if(bgReadying=bgReadySignal=null,err=res.error)throw err.stack+="\n"+localErr.stack,err;return res.data}}catch(e){if(!bgReadying)throw e.stack=localErr.stack,e}if(retry)throw new Error("Stylus could not connect to the background script.");await bgReadying}}},API=e.API=new Proxy({path:""},apiHandler),isFrame=t!==top;let bgReadySignal,bgReadying=!1,TDM=isFrame?0:r.prerendering?-1:1;function mapObj(obj,e,keys){if(!obj)return obj;const res={};for(const t of keys||Object.keys(obj))keys&&!(t in obj)||(res[t]=e?e(obj[t],t,obj):obj[t]);return res}function fetchWebDAV(url,init={}){return fetch(url,{...init,credentials:"omit",headers:{...init.headers,Authorization:`Basic ${btoa(`${this.username||""}:${this.password||""}`)}`}})}Symbol("client");const COMMANDS={__proto__:null},PATH=location.pathname,TTL=3e5,navLocks=navigator.locks,SharedWorker=e.SharedWorker,kWorker="_worker",NOP=()=>{};let bgLock,timer,webdavInstance,numJobs=0,lastBusy=0;function autoClose(delay){!delay&&bgLock&&(bgLock=null),bgLock||numJobs||timer||(timer=setTimeout(close,delay||Math.max(0,lastBusy+TTL-performance.now())))}function getWorkerPort(url,onerror){let worker;if(SharedWorker)return worker=new SharedWorker(url,"Stylus"),onerror&&(worker.onerror=onerror),worker.port;let target=e;return worker||(worker=target[kWorker]=new target.Worker(url),onerror&&(worker.onerror=onerror)),initChannelPort(worker,null)}function initChannelPort(target,msg,transfer){const e=new MessageChannel,port2=e.port2;return transfer?transfer[0]=port2:target.postMessage(msg,[port2]),e.port1}function onMessageError({data,source}){console.warn("Non-cloneable data",data),source.postMessage(JSON.stringify(data))}navLocks&&navLocks.request(PATH,()=>new Promise(NOP)),navigator.serviceWorker.onmessage=function(evt){const{id:once}=evt.data||{},exec=this,port=evt.ports[0];port.onerror=console.error,port.onmessage=onMessage,port.onmessageerror=onMessageError,once&&onMessage(evt);async function onMessage(portEvent){const data=portEvent.data,{args,id:e}=data.id?data:JSON.parse(data);let res,err;numJobs++,timer&&(timer=clearTimeout(timer));try{res=("function"==typeof exec?exec:exec[args.shift()]).apply(portEvent,args),res instanceof Promise&&(res=await res)}catch(e){res=void 0,e instanceof Error?(delete e.origin,err=[e,{...e}]):err=[e]}port.postMessage({id:e,res,err},portEvent._transfer),--numJobs||bgLock||autoClose(TTL),lastBusy=performance.now()}}.bind(COMMANDS),Object.assign(COMMANDS,{getWorkerPort(url){const e=getWorkerPort(url);return this._transfer=[e],e}}),Object.assign(COMMANDS,{keepAlive(val){val?bgLock||(timer&&(timer=clearTimeout(timer)),bgLock=navLocks.request("/sw.js",()=>autoClose())):autoClose()}}),Object.assign(COMMANDS,{isDark:()=>matchMedia("(prefers-color-scheme:dark)").matches,createObjectURL:URL.createObjectURL,revokeObjectURL:URL.revokeObjectURL,webdav:(cmd,...args)=>webdavInstance[cmd](...args),webdavInit:async cfg=>{var url;return webdavInstance||await(url="js/webdav.js",new Promise((resolve,reject)=>r.head.appendChild(Object.assign(r.createElement("script"),{src:url,onload:resolve,onerror:reject})))),cfg.fetch=fetchWebDAV.bind(cfg),cfg.getAccessToken=()=>API.sync.getToken("webdav"),webdavInstance=e.webdav(cfg),mapObj(webdavInstance,e=>"function"==typeof e?null:e)}})})()}