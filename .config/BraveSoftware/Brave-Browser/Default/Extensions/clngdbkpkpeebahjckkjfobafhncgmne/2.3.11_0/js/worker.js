{const e=self;(()=>{Symbol("client");const COMMANDS={__proto__:null},PATH=location.pathname,TTL=3e5,navLocks=navigator.locks,NOP=()=>{};let bgLock,timer,numJobs=0,lastBusy=0;function initRemotePort(evt){const{id:once}=evt.data||{},exec=this,port=evt.ports[0];async function onMessage(portEvent){const data=portEvent.data,{args,id:e}=data.id?data:JSON.parse(data);let res,err;numJobs++,timer&&(timer=clearTimeout(timer));try{res=("function"==typeof exec?exec:exec[args.shift()]).apply(portEvent,args),res instanceof Promise&&(res=await res)}catch(e){res=void 0,e instanceof Error?(delete e.origin,err=[e,{...e}]):err=[e]}port.postMessage({id:e,res,err},portEvent._transfer),--numJobs||bgLock||autoClose(TTL),lastBusy=performance.now()}port.onerror=console.error,port.onmessage=onMessage,port.onmessageerror=onMessageError,once&&onMessage(evt)}function autoClose(delay){bgLock||numJobs||timer||(timer=setTimeout(close,delay||Math.max(0,lastBusy+TTL-performance.now())))}function onMessageError({data,source}){console.warn("Non-cloneable data",data),source.postMessage(JSON.stringify(data))}navLocks&&navLocks.request(PATH,()=>new Promise(NOP));const loadedUrls=[],KEY="importScriptsOnce",importScriptsOnce=e[KEY]=(...urls)=>{(urls=urls.filter(e=>!loadedUrls.includes(e))).length&&(loadedUrls.push(...urls),importScripts(...urls))};Object.assign(COMMANDS,{compileUsercss:[()=>compileUsercss,"usercss-compiler.js"],nullifyInvalidVars:[()=>metaParser.nullifyInvalidVars,"meta-parser.js"],parseMozFormat:[()=>extractSections,"moz-parser.js","parserlib.js"],parseUsercssMeta:[()=>metaParser.parse,"meta-parser.js"]});for(const e in COMMANDS)if(Array.isArray(COMMANDS[e])){const[getFunc,...files]=COMMANDS[e];COMMANDS[e]=function(){return importScriptsOnce(...files),(COMMANDS[e]=getFunc()).apply(this,arguments)}}let sugarss=null;Object.assign(COMMANDS,{csslint:(code,config)=>(importScriptsOnce("parserlib.js","csslint.js"),CSSLint.verify(code,config).messages.map(e=>Object.assign(e,{rule:{id:e.rule.id}}))),getCssPropsValues(){importScriptsOnce("parserlib.js");const{css:{GlobalKeywords,NamedColors,Parser:{AT:e},Properties},util:{describeProp,VTFunctions}}=parserlib,atKeys=["@-moz-document","@starting-style"],keys=Object.keys(Properties).sort(),COLOR="<color>",rxColor=RegExp(`${COLOR}|${describeProp(COLOR).replace(/[()|]/g,"\\$&")}|~~~`,"g"),rxFunc=/([-\w]+\().*?\)/g,rxNonWord=/(?:<.+?>|[^-\w<(]+\d*)+/g,res={},cmp=(e,s)=>"-"===e[0]&&"-"!==s[0]?1:e<s?-1:e>s;for(const s in e)"document"!==s&&atKeys.push("@"+s);for(let e,s,t=0;t<keys.length;t++){if(e=keys[t],s=Properties[e],"string"==typeof s){let last="";const uniq=[],vNoColor=s.replace(rxColor,"~~~"),desc=describeProp(vNoColor),descNoColors=desc.replace(rxColor,""),words=descNoColors.replace(rxFunc,"z-$1").split(rxNonWord).sort(cmp);for(let e of words)e.startsWith("z-")&&(e=e.slice(2)),e!==last&&uniq.push(last=e);desc===descNoColors&&s===vNoColor||uniq.push(COLOR),s=uniq.join("\n")}else-1===s?e="":s="";e&&(res[e+=": "]=s),keys[t]=e}return{all:res,ats:atKeys.sort(),colors:NamedColors.join("\n")+"\n"+Object.keys(VTFunctions.color).join("(\n")+"(",global:"\n"+GlobalKeywords.join("\n"),keys:keys.filter(Boolean)}},getRules:linter=>ruleRetriever[linter](),metalint(code){importScriptsOnce("meta-parser.js");const result=metaParser.lint(code);return result.errors=result.errors.map(err=>({code:err.code,args:err.args,message:err.message,index:err.index})),result},async stylelint(opts){importScriptsOnce("stylelint.js"),stylelint.SugarSSParser.prototype.checkSemicolon=ovrCheckSemicolon;for(const e in opts.config.rules)stylelint.rules[e]||delete opts.config.rules[e];for(let pass=2;--pass>=0;){"stylus"===opts.mode&&(null==sugarss&&(sugarss=!opts.code.includes("{")),opts.config.customSyntax=sugarss?"sugarss":"");const res=(await stylelint.lint(opts)).results[0],errors=res.parseErrors.concat(res.warnings);if(!(sugarss&&pass&&errors[0]&&"Unnecessary curly bracket (CssSyntaxError)"===errors[0].text))return collectStylelintResults(errors,opts);sugarss=!sugarss}}});const ruleRetriever={csslint:()=>(importScriptsOnce("csslint.js"),CSSLint.getRuleList().map(rule=>{const output={};for(const[key,value]of Object.entries(rule))"function"!=typeof value&&(output[key]=value);return output})),stylelint(){importScriptsOnce("stylelint.js");const options={},rxPossible=/\bpossible:("[^"]*?"|\[[^\]]*?]|\{[^}]*?})/g,rxString=/"([-\w\s]{3,}?)"/g;for(const[e,rule]of Object.entries(stylelint.rules)){const ruleCode=`${rule()}`,sets=[];let s,mStr;for(;s=rxPossible.exec(ruleCode);){const possible=s[1],set=[];for(;mStr=rxString.exec(possible);){const e=mStr[1];e.includes(" ")?set.push(...e.split(/\s+/)):set.push(e)}possible.includes("ignoreAtRules")&&set.push("ignoreAtRules"),possible.includes("ignoreShorthands")&&set.push("ignoreShorthands"),set.length&&sets.push(set)}options[e]=sets}return options}};function collectStylelintResults(messages,{mode}){const isLess="text/x-less"===mode,slashCommentAllowed=isLess||"stylus"===mode,res=[];for(const e of messages){const{rule}=e,msg=e.text.replace(/^Unexpected\s+/,"").replace(` (${rule})`,"");if(slashCommentAllowed&&msg.includes('"//"')||isLess&&/^unknown at-rule "@[-\w]+:"/.test(msg))continue;const{line:s,column:t}=e;res.push({from:{line:s-1,ch:t-1},to:{line:(e.endLine||s)-1,ch:(e.endColumn||t)-1},message:msg[0].toUpperCase()+msg.slice(1),severity:e.severity,rule})}return res}function ovrCheckSemicolon(e){for(;e.length&&";"===e[e.length-1][0];)e.pop()}e.onconnect=e.onmessage=initRemotePort.bind(COMMANDS)})()}